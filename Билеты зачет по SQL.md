
> [!question]- Структура БД, свойства СУБД.
> ***Структура БД***
>>	База данных (БД) — это организованная совокупность данных, структурированная таким образом, чтобы упростить хранение, обработку и поиск информации.
>	
>>	Таблица — одна из основных структур хранения данных. Состоит из строк (записей) и столбцов (полей).
>	
>>	Первичный ключ (Primary Key) — уникальный идентификатор для каждой строки в таблице.
>	
>>	СУБД (DBMS) — система управления базами данных (например, MySQL, PostgreSQL, SQLite)
>
>  ***Свойства СУБД***
>>	1.Целостность данных
>	
>>	2.Безопасность и надёжность
>	 
>>	3.Высокая производительность
>	
>>	4.Масштабируемость

> [!question]- Основные типы данных в языке SQL. Базовые операции над типами.
> 
> ***Типы данных***
>  
>> 	CHAR(size) - строка фиксированного размера size
>
>> 	VARCHAR(size) - строка переменной длины длины не более size
>
>> 	BOOL/BOOLEAN
>	
>> 	SMALLINT, MEDIUMINT, INT/INTEGER - целые числа (16, 32 и 64 бита сответственно)
> 
>> 	FLOAT, DOUBLE - числа с плавающей точкой размером 32 и 64 бита соответственно
>	
>> 	DATE, TIME, DATETIME, TIMESTAMP
>> 	Также в любой* колонке могут встречаться NULL-значения.
> 
> 
> ***Базовые операции***
>> 	Стандартные математические операции: +, -, *, /, %
> 	
>>	Битовые операции: &, ˆ , |, ∼
>	
>>	Операции сравнения: >, <, <=, >=, =, <>, BETWEEN
>	
>>	Логические операции: AND, OR, NOT, ALL, ANY/SOME, IN, LIKE, IS NULL, IS NOT NULL
>	
>>	Приведение типов: cast(column_name as type)
> 

> [!question]- Команда SELECT. Назначение и синтаксис. Привести примеры.
>**Назначение**
>>	SELECT указывает, какие столбцы (или вычисления) нужно вывести.
>>	FROM указывает, из какой таблицы получаем данные.  
>>	WHERE — условие фильтрации строк.  
>>	GROUP BY — группировка по одному или нескольким столбцам.
>> 	HAVING — условие для отфильтрованных групп.  
>> 	ORDER BY — сортировка (по возрастанию или убыванию).
>>	LIMIT — ограничение количества возвращаемых строк.
>	
> **Синтаксис**
> 
>>```sql
>>SELECT <столбцы или выражения>
>>FROM <название_таблицы>
>>[WHERE <условие>]
>>[GROUP BY <столбцы>]
>>[HAVING <условие_для_групп>]
>>[ORDER BY <столбцы> [ASC|DESC]]
>>[LIMIT <количество_строк>];
>>```
>
>**Примеры**
>	
>	Структура таблицы employees:
>>		id (PRIMARY KEY)  
>>		name  
>>		position
>>		salary
>Запрос:
>>```sql
>>SELECT name, position
>>FROM employees;
>>```
>Описание: Этот запрос вернёт столбцы name и position из таблицы employees.

>[!question]- Псевдонимы при выборке данных.Синтаксис и мотивация применения. Привести примеры. Синтаксис и мотивация применения
>Определение и мотивация применения
>>	- Aliasing позволяет давать временные имена столбцам или таблицам.  
>>	- Удобно при использовании вычисляемых полей или при работе с длинными названиями таблиц.
>Примеры:
>
>>	Структура таблицы employees:
>>	
>>		id (PRIMARY KEY)  
>>		name  
>>		position
>>		salary
>		
>Пример: Использование псевдонима столбца
>>```sql
>> SELECT name AS employee_name,
>> salary * 1.2 AS new_salary
>> FROM employees;
>>-- AS задаёт псевдоним для отображаемого столбца.  
>>--В результате в итоговой выборке столбец будет называться employee_name, а второй — new_salary.
>>```
>
>Пример: Псевдоним таблицы
>>```sql
>>SELECT e.name, e.position
>>FROM employees AS e;
>>```
>

> [!question]- Основные аггрегирующие функции. Привести примеры запросов.
>**Функции**
>>	MIN - минимальное значение в колонке MAX - максимальное значение в колонке 
>>	AVG - среднее значение в колонке  
>>	SUM - сумма значений в колонке
>>	COUNT - количество значений в колонке  
>>	Важно: все аггрегирующие функции игнорируют NULL-значения кроме COUNT.
>	
>**Примеры**
>>```sql
>>SELECT MIN(цена) AS минимальная_цена
>>FROM товары;
>>```
>
>>```sql
>>SELECT город, AVG(возраст) AS средний_возраст
>>FROM клиенты
>>GROUP BY город
>>HAVING AVG(возраст) > 30;
>>-- Этот запрос возвращает средний возраст клиентов в каждом городе.
>>```
>
>>```sql
>>SELECT SUM(цена) AS общая_цена
>>FROM заказы;
>>```
>
>>```sql
>>SELECT COUNT(*) AS количество_заказов
>>FROM заказы;
>> -- **COUNT** - возвращает количество строк в таблице.
>>```

> [!question]- Фильтрация результатов запроса. Привести несколько разных по сложности примеров.
>
>**Определение**
>	
>>	Фильтрация результатов запроса - это процесс ограничения количества строк, возвращаемых запросом, на основе определенных условий. В SQL для фильтрации результатов используются операторы WHERE, HAVING и BETWEEN.
>
>Примеры:
>>	 
>**Простые примеры** 
>
>>	1. Фильтрация по одному условию: 
>
>>```sql
>>SELECT *
>>FROM клиенты
>>WHERE возраст > 30;
>>```
>
>
>>	2. Фильтрация по двум условиям: 
>
>>```sql 
>>SELECT * 
>>FROM клиенты 
>>WHERE возраст > 30 AND город = 'Москва'; 
>>``` 
>	
>**Примеры со сложными условиями**
>
>>	1. Фильтрация по диапазону значений:
>
>>```sql
>>SELECT *
>>FROM клиенты
>>WHERE возраст BETWEEN 25 AND 40;
>>```
>
>
>>	2. Фильтрация по списку значений:
>
>>```sql
>>SELECT *
>>FROM клиенты
>>WHERE город IN ('Москва', 'Санкт-Петербург', 'Киев');
>>```
>
>
>>	3. Фильтрация по условию, содержащему NULL:
>
>>```sql
>>SELECT *
>>FROM клиенты
>>WHERE телефон IS NOT NULL;
>>```
>	
>**Примеры с использованием оператора HAVING**
>
>>	1. Фильтрация по среднему значению:
>
>>```sql
>>SELECT город, AVG(возраст) AS средний_возраст
>>FROM клиенты
>>GROUP BY город
>>HAVING AVG(возраст) > 30;
>>```
>
>
>>	2. Фильтрация по нескольким средним значениям:
>
>>```sql
>>SELECT город, AVG(возраст) AS средний_возраст, SUM(доход) AS общий_доход
>>FROM клиенты
>>GROUP BY город
>>HAVING AVG(возраст) > 30 AND SUM(доход) > 100000;
>>```


- Группировка данных по признакам. Группировка с фильтрацией. Привести несколько разных по сложности примеров.
- Вложенные запросы. Мотивация использования. Привести несколько разных по сложности примеров.
- JOIN. Различные виды JOIN’ов. Привести несколько примеров с разными видами.
- Различия между JOIN и вложенными запросами (производительность, читабельность, применимость). Привести пример аналогичных запросов с использованием JOIN и подзапросов.
- Типы связей между таблицами в БД. Привести примеры структур.
- ER-модель. Основные элементы и правила построения. Чтение готовой ER-модели.
- Создание таблицы. Синтаксис. Обязательные и опциональные ключевые слова. Объявление внешних ключей в таблице. Привести пример.
- Изменение структуры таблицы. Особенности реализации стандарта SQL в SQLite. Привести несколько примеров.
- Добавление и удаление данных в таблице (в том числе разобрать случай с наличием связей в таблице). Возможные нарушения целостности структуры БД при модифицирующих операциях. При- вести несколько примеров.
- Ограничения целостности при создании таблицы. Привести основные типы и несколько осмысленных примеров.
- Реализация различных типов связей средствами SQL. Приести пример структуры БД не менее чем из 4 таблиц с различными типами связей.
- Создание и удаление представлений в SQL. Отличия представлений от таблиц. Привести несколько примеров.
- Оконные функции. Общий синтаксис, основные функции. Отличия оконных функций от аггрегирующих.
- Различные виды упорядочивания в оконных функциях. Привести несколько примеров.
- Основные правила работы с sqlite3. Создание БД и подключение к уже существующей БД. Описание основных объектов при работе с БД (подключение, курсор).
- Правила работы при запросе и изменении данных в БД с помощью sqlite3.
- Плейсхолдеры. Назвать минимум 2 причины их применения вместо форматных строк.
- Object-relational mapping. Что такое и зачем применяется. Плюсы и минусы по сравнению с использованием SQL-скриптов.
- Основные правила работы с SQLAlchemy. Создание БД и подключение к уже существующей БД. Описание основных объектов при работе с БД (подключение, сессия).
- Правила создания моделей и работы с ними. Создание колонок (примитивных типов).
- Описание различных видов связей между моделями в SQLAlchemy. Привести несколько примеров.
- Правила составления запросов на выборку и изменение данных в SQLAlchemy.
- Чтение готового SQL-запроса и принцип его работы.
- Переписать готовый SQL-запрос с помощью SQLAlchemy.

