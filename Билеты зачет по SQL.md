
> [!question]- Структура БД, свойства СУБД.
> ***Структура БД***
>>	База данных (БД) — это организованная совокупность данных, структурированная таким образом, чтобы упростить хранение, обработку и поиск информации.
>
>>	Таблица — одна из основных структур хранения данных. Состоит из строк (записей) и столбцов (полей).
>
>>	Первичный ключ (Primary Key) — уникальный идентификатор для каждой строки в таблице.
>
>>	СУБД (DBMS) — система управления базами данных (например, MySQL, PostgreSQL, SQLite)
>
>  ***Свойства СУБД***
>>	1.Целостность данных
>
>>	2.Безопасность и надёжность
>
>>	3.Высокая производительность
>
>>	4.Масштабируемость

> [!question]- Основные типы данных в языке SQL. Базовые операции над типами.
>
> ***Типы данных***
>
>> 	CHAR(size) - строка фиксированного размера size
>
>> 	VARCHAR(size) - строка переменной длины длины не более size
>
>> 	BOOL/BOOLEAN
>
>> 	SMALLINT, MEDIUMINT, INT/INTEGER - целые числа (16, 32 и 64 бита сответственно)
>
>> 	FLOAT, DOUBLE - числа с плавающей точкой размером 32 и 64 бита соответственно
>
>> 	DATE, TIME, DATETIME, TIMESTAMP
>> 	Также в любой* колонке могут встречаться NULL-значения.
>
>
> ***Базовые операции***
>> 	Стандартные математические операции: +, -, *, /, %
>
>>	Битовые операции: &, ˆ , |, ∼
>
>>	Операции сравнения: >, <, <=, >=, =, <>, BETWEEN
>
>>	Логические операции: AND, OR, NOT, ALL, ANY/SOME, IN, LIKE, IS NULL, IS NOT NULL
>
>>	Приведение типов: cast(column_name as type)
>

> [!question]- Команда SELECT. Назначение и синтаксис. Привести примеры.
>**Назначение**
>>	SELECT указывает, какие столбцы (или вычисления) нужно вывести.
>>	FROM указывает, из какой таблицы получаем данные.
>>	WHERE — условие фильтрации строк.
>>	GROUP BY — группировка по одному или нескольким столбцам.
>> 	HAVING — условие для отфильтрованных групп.
>> 	ORDER BY — сортировка (по возрастанию или убыванию).
>>	LIMIT — ограничение количества возвращаемых строк.
>
> **Синтаксис**
>
>>```sql
>>SELECT <столбцы или выражения>
>>FROM <название_таблицы>
>>[WHERE <условие>]
>>[GROUP BY <столбцы>]
>>[HAVING <условие_для_групп>]
>>[ORDER BY <столбцы> [ASC|DESC]]
>>[LIMIT <количество_строк>];
>>```
>
>**Примеры**
>
>	Структура таблицы employees:
>>		id (PRIMARY KEY)
>>		name
>>		position
>>		salary
>Запрос:
>>```sql
>>SELECT name, position
>>FROM employees;
>>```
>Описание: Этот запрос вернёт столбцы name и position из таблицы employees.

>[!question]- Псевдонимы при выборке данных.Синтаксис и мотивация применения. Привести примеры. Синтаксис и мотивация применения
>Определение и мотивация применения
>>	- Aliasing позволяет давать временные имена столбцам или таблицам.
>>	- Удобно при использовании вычисляемых полей или при работе с длинными названиями таблиц.
>Примеры:
>
>>	Структура таблицы employees:
>>
>>		id (PRIMARY KEY)
>>		name
>>		position
>>		salary
>
>Пример: Использование псевдонима столбца
>>```sql
>> SELECT name AS employee_name,
>> salary * 1.2 AS new_salary
>> FROM employees;
>>-- AS задаёт псевдоним для отображаемого столбца.
>>--В результате в итоговой выборке столбец будет называться employee_name, а второй — new_salary.
>>```
>
>Пример: Псевдоним таблицы
>>```sql
>>SELECT e.name, e.position
>>FROM employees AS e;
>>```
>

> [!question]- Основные аггрегирующие функции. Привести примеры запросов.
>**Функции**
>>	MIN - минимальное значение в колонке MAX - максимальное значение в колонке
>>	AVG - среднее значение в колонке
>>	SUM - сумма значений в колонке
>>	COUNT - количество значений в колонке
>>	Важно: все аггрегирующие функции игнорируют NULL-значения кроме COUNT.
>
>**Примеры**
>>```sql
>>SELECT MIN(цена) AS минимальная_цена
>>FROM товары;
>>```
>
>>```sql
>>SELECT город, AVG(возраст) AS средний_возраст
>>FROM клиенты
>>GROUP BY город
>>HAVING AVG(возраст) > 30;
>>-- Этот запрос возвращает средний возраст клиентов в каждом городе.
>>```
>
>>```sql
>>SELECT SUM(цена) AS общая_цена
>>FROM заказы;
>>```
>
>>```sql
>>SELECT COUNT(*) AS количество_заказов
>>FROM заказы;
>> -- **COUNT** - возвращает количество строк в таблице.
>>```

> [!question]- Фильтрация результатов запроса. Привести несколько разных по сложности примеров.
>
>**Определение**
>
>>	Фильтрация результатов запроса - это процесс ограничения количества строк, возвращаемых запросом, на основе определенных условий. В SQL для фильтрации результатов используются операторы WHERE, HAVING и BETWEEN.
>
>Примеры:
>>
>**Простые примеры**
>
>>	1. Фильтрация по одному условию:
>
>>```sql
>>SELECT *
>>FROM клиенты
>>WHERE возраст > 30;
>>```
>
>
>>	2. Фильтрация по двум условиям:
>
>>```sql
>>SELECT *
>>FROM клиенты
>>WHERE возраст > 30 AND город = 'Москва';
>>```
>
>**Примеры со сложными условиями**
>
>>	1. Фильтрация по диапазону значений:
>
>>```sql
>>SELECT *
>>FROM клиенты
>>WHERE возраст BETWEEN 25 AND 40;
>>```
>
>
>>	2. Фильтрация по списку значений:
>
>>```sql
>>SELECT *
>>FROM клиенты
>>WHERE город IN ('Москва', 'Санкт-Петербург', 'Киев');
>>```
>
>
>>	3. Фильтрация по условию, содержащему NULL:
>
>>```sql
>>SELECT *
>>FROM клиенты
>>WHERE телефон IS NOT NULL;
>>```
>
>**Примеры с использованием оператора HAVING**
>
>>	1. Фильтрация по среднему значению:
>
>>```sql
>>SELECT город, AVG(возраст) AS средний_возраст
>>FROM клиенты
>>GROUP BY город
>>HAVING AVG(возраст) > 30;
>>```
>
>
>>	2. Фильтрация по нескольким средним значениям:
>
>>```sql
>>SELECT город, AVG(возраст) AS средний_возраст, SUM(доход) AS общий_доход
>>FROM клиенты
>>GROUP BY город
>>HAVING AVG(возраст) > 30 AND SUM(доход) > 100000;
>>```


- Группировка данных по признакам. Группировка с фильтрацией. Привести несколько разных по сложности примеров.
- Вложенные запросы. Мотивация использования. Привести несколько разных по сложности примеров.
- JOIN. Различные виды JOIN’ов. Привести несколько примеров с разными видами.
- Различия между JOIN и вложенными запросами (производительность, читабельность, применимость). Привести пример аналогичных запросов с использованием JOIN и подзапросов.
- Типы связей между таблицами в БД. Привести примеры структур.
- ER-модель. Основные элементы и правила построения. Чтение готовой ER-модели.
- Создание таблицы. Синтаксис. Обязательные и опциональные ключевые слова. Объявление внешних ключей в таблице. Привести пример.
- Изменение структуры таблицы. Особенности реализации стандарта SQL в SQLite. Привести несколько примеров.
- Добавление и удаление данных в таблице (в том числе разобрать случай с наличием связей в таблице). Возможные нарушения целостности структуры БД при модифицирующих операциях. При- вести несколько примеров.
- Ограничения целостности при создании таблицы. Привести основные типы и несколько осмысленных примеров.
- Реализация различных типов связей средствами SQL. Приести пример структуры БД не менее чем из 4 таблиц с различными типами связей.
- Создание и удаление представлений в SQL. Отличия представлений от таблиц. Привести несколько примеров.
> [!question]- Оконные функции. Общий синтаксис, основные функции. Отличия оконных функций от аггрегирующих.
>**Определение**
>>Оконные функции (window functions) — специальные функции SQL, позволяющие выполнять вычисления по «окну» строк .
>
> **Синтаксис**
>>```sql
>>function()  OVER (
>>[PARTITION BY column_list] 
>>[ORDER BY column_list]
>>)
>>```
>
>>	PARTITION BY
>>группирует строки в «окна» по колонке(-ам).
>
>>	ORDER BY
>>порядок, важный для функции ранжирования (function()) .
>
>**Основные функции**
>>	ROW_NUMBER()
>>дает порядковый номер каждой строки в рамках указанного окна.
>
>>	RANK()
>>дает "топ" (т.е. если значение одно, то топ одинаковый), в котором находится вхождение (с пропуском мест), e.g.  1, 1, 3, ...
>
>>	DENSE_RANK() 
>>дает "топ", в котором находится вхождение (без пропуска мест), e.g. 1, 1, 2
>
>>	LAG(return_value, offset, default_value) 
>>дает значение из offset-ой предыдущей строки столбца return_value (по дефолту offset = 1, т.е. значение на строку выше). Если этой строки нет, то дает default_value (по дефолту default_value = NULL)
>
>>	LEAD(return_value, offset, default_value)
>>дает значение из offset-ой следующей строки столбца return_value (по дефолту offset = 1, т.е. значение на строку ниже). Если этой строки нет, то дает default_value (по дефолту default_value = NULL)
>
>>	AVG()
> 
>**Отличия от аггрегирующих функций**
>> Не  свертывают строки в одну, а «распределяют» вычисленное значение по каждой строке.
>
>>Поддерживают больше функций (не аггрегатных).
>
>**Пример**
>>```sql
>>SELECT
>>	employee_id,
>>	salary,
>>	AVG(salary)  OVER (
>>		PARTITION BY dept_id 
>>	)  AS avg_salary_in_dept
>>FROM employees;
>>```
>>Для каждого сотрудника возвращает его зарплату и среднюю зарплату по отделу

> [!question]- Различные виды упорядочивания в оконных функциях. Привести несколько примеров.
> **Теория**
>>	ASC
>>по возрастанию (дефолт).
>
>>	DESC
>> по убывания
>
> **Примеры**
>> ```sql
>> SELECT 
>> 	RANK() OVER (ORDER BY salary DESC) AS salary_rank
>> FROM employees;
>>  ```
>>  Возвращает топ зарплаты
>
>>```sql
>>SELECT
>>	RANK() OVER (ORDER BY salary) AS salary_bottom_rank
>>FROM employees;
>>```
>>Возвращает нижний топ зарплаты

 > [!question]- Основные правила работы с sqlite3. Создание БД и подключение к уже существующей БД. Описание основных объектов при работе с БД (подключение, курсор).
 >**Синтаксис и теория**
 >> Является встроенным модулем.
>> ```python
>> import sqlite
>> ```
 >
 >> Нужно подключение к бд через sqlite.connect(), оно же откртие/создание файла (т.е. если файла нет, то он создастся).
>> ```python
>> conn = sqlite3.connect('example.db')
>> ```
 >
 >> Все запросы выполняются с помощью курсора sqlite3.connect().cursor()
>> ```python
>> cursor = conn.cursor()
>> ```
 >
>> В конце обзяательно нужно закрыть файл/соединение через sqlite3.connection().close()
>> ```python
>> conn.close()
>> ```
>
>>***Итого***
>>```python
>>import sqlite3
>>conn = sqlite3.connect('example.db')
>>cursor = conn.cursor()
>>conn.close()
>>```

>[!question]- Правила работы при запросе и изменении данных в БД с помощью sqlite3.
>>**Синтаксис и теория**
>
>>Все запросы выполняются с помощью курсора, у которого есть метод execute()
>>```python
>>cursor.execute(sql_script)
>>```
>
>>Для фиксирования (сохранения) изменений у соединения есть метод commit()
>>```python
>>conn.commit()
>>```
>
>**Примеры**
>
>>Создание таблицы
>>```sql
>>import sqlite3
>>conn = sqlite3.connect(’example.db’)
>>cursor = conn.cursor()
>>cursor.execute(’’’
>>	CREATE TABLE IF NOT EXISTS users (
>>		id INTEGER PRIMARY KEY AUTOINCREMENT,
>>		username TEXT NOT NULL,
>>		age INTEGER,
>>		city TEXT
>>	)
>>’’’)
>>conn.commit() 
>>conn.close()
>>```
>
>>Добавление данных
>>```sql
>>import sqlite3
>>conn = sqlite3.connect(’example.db’)
>>cursor = conn.cursor()
>>cursor.execute(’’’
>>	INSERT INTO users (username, age, city)
>>	VALUES (?, ?, ?)
>>’’’, (’Иван’, 25, ’Москва’)) 
>>conn.commit() 
>>conn.close()
>>```
>>Что такое плейсхолдеры написано в вопросе ниже
>
>>Выборка данных
>>```sql
>>import sqlite3
>>conn = sqlite3.connect(’example.db’)
>>cursor = conn.cursor()
>>cursor.execute('SELECT id, username, age, city FROM users')
>>rows = cursor.fetchall()
>>for row in rows:
>>	print(row)
>>conn.close()
>>```
>
>***Фетч*** (метод курсора)
>
>> 	fetchall()
>> возвращает список кортежей с результатами
>
>>	fetchone()
>> возвращает одну строку
>
>> 	fetchmany(n)
>> возвращает n строк
>
>**Еще примеры**
>>Обновление
>>```sql
>>cursor.execute(’’’
>>	UPDATE users
>>	SET age = ?
>>	WHERE username = ?
>>’’’, (26, ’Иван’))
>>```
>
>>Удаление
>>```sql
>>cursor.execute(’’’
>>	DELETE FROM users
>>	WHERE username = ?
>>’’’, (’Иван’,))
>>```

>[!question]- Плейсхолдеры. Назвать минимум 2 причины их применения вместо форматных строк.
>**Теория и синтаксис**
>>Скрипт может использовать плейсхолдеры (?). Тогда в execute вторым аргументом нужно передать кортеж значений, по длинне такой же, как и количество плейсхолдеров.
>
>>executemany() используется, чтобы один скрипт выполнить несколько раз с разными кортежами значений, которые передаются списком вторым аргументом
>
>>**Примеры**
>>Добавление данных
>>```sql
>>import sqlite3
>>conn = sqlite3.connect(’example.db’)
>>cursor = conn.cursor()
>>cursor.execute(’’’
>>	INSERT INTO users (username, age, city)
>>	VALUES (?, ?, ?)
>>’’’, (’Иван’, 25, ’Москва’)) 
>>conn.commit() 
>>conn.close()
>>```
>
>>Добавление списка данных
>>```sql
>>import sqlite3
>>conn = sqlite3.connect(’example.db’)
>>cursor = conn.cursor()
>>params = [
>>	(’Иван’, 25, ’Москва’),
>>	('Саша', 17, 'Москва')
>>]
>>cursor.executemany(’’’
>>	INSERT INTO users (username, age, city)
>>	VALUES (?, ?, ?)
>>’’’, params) 
>>conn.commit() 
>>conn.close()
>>```
>
>**Причины их применения вместо форматных строк**
>>Защита от SQL-инъекций (безопасность данных)
>
>>Добавление сразу спика значений с помощью executemany()

>[!question]- Object-relational mapping. Что такое и зачем применяется. Плюсы и минусы по сравнению с использованием SQL-скриптов.
>**Определение**
>>ORM  (Object-relational mapping, объектно-реляционное отображение) - технология, которая связывает бд с концепциями ООП, создавая «виртуальную объектную базу данных»
>
>**Плюсы по сравнению с использованием SQL-скриптов**
>> Отделение бизнес-логики от конкретных SQL-запросов
>
>> Кросс-база: без изменения кода можно подключить другую СУБД.
>
>> Удобство: вместо таблиц и строк — привычные классы и объекты. Уменьшает количество кода
>
>>Безопасность: автоматическая экранизация параметров, меньше риска SQL-инъекций.
>
>**Минусы**
>> Высокий уровень абстракции (более большая отдаленность от самой бд).
>
>>Может быть медленнее.
>
>**Литература**
>[пост про плюсы и минусы ORM](https://stackoverflow.com/questions/4667906/the-advantages-and-disadvantages-of-using-orm) (прочитайте ответы)


- Основные правила работы с SQLAlchemy. Создание БД и подключение к уже существующей БД. Описание основных объектов при работе с БД (подключение, сессия).
- Правила создания моделей и работы с ними. Создание колонок (примитивных типов).
- Описание различных видов связей между моделями в SQLAlchemy. Привести несколько примеров.
- Правила составления запросов на выборку и изменение данных в SQLAlchemy.
- Чтение готового SQL-запроса и принцип его работы.
- Переписать готовый SQL-запрос с помощью SQLAlchemy.
